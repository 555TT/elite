# 数据库逻辑删除后，怎么做唯一性约束？

假设我们有一张开通表，里面记录了用户的服务开通记录service_record,主要有以下几个字段

![](C:\Users\DELL\Desktop\elite\assets\逻辑删除1.png)

然后如果有用户退出的时候，我们需要记录用户的退出状态，这时候一般我们都不能做物理删除的，因为数据库的物理删除意味着数据都没有了，那么后续的各种数据分析，报表等都没办法做了，所以大多数选择逻辑删除，那么就是引入一个新的字段：

![](C:\Users\DELL\Desktop\elite\assets\逻辑删除2.png)

这个字段一般定义为deleted或者is_deleted,常见的做法是默认是0，表示未删除，如果逻辑删除的话则把他设置为1。 那么问题来了，我们怎么避免用户在开通的时候因为并发导致插入多条开通记录呢？

当然，可以加分布式锁，但是不管怎么做，最终都得在数据库层面做兜底，而一般这种情况就需要做一个唯一性约束。

可是同一个用户是可以有多条开通记录的，唯一性约束如果用user_id+product_code那么就肯定是不行的，会导致用户无法多次开通。但是如果再加上is_deleted,是可以区分开通和退出了，但是一个用户如果多次退出又不行了，那么该如何支持这种业务需求呢？后面一共有四种方案，前两个方案是如果直接做物理删除如何实现业务需求！后面两个是如果就是不能做物理删除该怎么办？

## 方案一，物理删除+数据归档

最简单的方案就是直接做物理删除了，但是物理删除怎么实现数据分析、报表等功能呢，就是说如何做数据留痕呢？简单的方案就是做数据归档或者离线表。就是说再创建一张service_record_his表，然后再用户退出时，在同一个事务中把service_record表中的数据插入到service_record_his中，然后再把service_record表中的记录删除。

## 方案二，复用一条开通记录+记录开通流水

为了解决我们的数据留痕的问题，不一定非要基于service_record这张主表，像我们的业务来说，基本上一些核心操作都是有流水表的，如service_record_stream,用户相关的各种操作，开通、退出、冻结、解冻等等都插入一条流水。这样我们就可以保证service record表中针对同一个用户+产品，只会有一条记录，用户开通后，状态为 ACTIVE,用户退出后，状态为QUIT。用户重新开通，再更新为ACTIVE。 然后所以数据的分析需求，都基于流水表来做，流水表一般比主表多几个字段。如：

![](C:\Users\DELL\Desktop\elite\assets\逻辑删除3.png)

## 方案三，>0都表示逻辑删除

前面两个方案都是绕开了我们的问题，那么能不能直接通过加唯一性约束的方式解决？有一个办法，那就是之所以我们没动法把user_id+product_code+is_deleted作为一个联合的唯一索引，主要是因为is_deleted只有0和1两种情况 ，那只要解决这个问题就行了，核心的思想就是0表示未删除，只要大于0都表示删除。那么就可以在每次删除之后，is_deleted都+1，is_deleted=1表示第一次退出，is_deleted=2表示第2次退出........

这么做还是有点麻烦，而且也可能有一个并发情况下导致这个重复了，虽然概率很低很低。但是我们前面说了，数据库唯一性约束用于兜底，该有的分布式锁还是有的，所以并发问题倒也还好。不过还是可以简单点，那就是在用户退出的时候，直接把这条service_record的主键（前提需要是自增的ID)设置到is_deleted中。is_deleted=43532表示用户退出，is deleted=64532也表示退出了。。。

## 方案四，引入一个新的字段

除了上面的方式是改造is_deleted以外，还有一个办法，那就是引入一个新的字段，如deleted_time表示这条记录被删除的时间戳然后user id+product_code+is _deleted+deleted_time一起，做一个联合的唯一索引。 当然，你也可以把is_deleted去掉，然后是否被逻辑删除通过deleted_time,是否为空来判断，那么就又和第三个方案有点像了。